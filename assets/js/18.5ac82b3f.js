(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{246:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"es6总结文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6总结文章","aria-hidden":"true"}},[t._v("#")]),t._v(" ES6总结文章")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("《ECMAScript 6 入门》(阮一峰)"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cxymsg.com/guide/vue.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端面试与进阶指南"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"http://blog.poetries.top/FE-Interview-Questions/",target:"_blank",rel:"noopener noreferrer"}},[t._v("FE-Interview"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5d9bf530518825427b27639d",target:"_blank",rel:"noopener noreferrer"}},[t._v("1.5万字概括ES6全部特性(看图就能记下，值得收藏)"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"强缓存和协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存和协商缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 强缓存和协商缓存")]),t._v(" "),e("h3",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),e("p",[e("strong",[t._v("Cache-Control：")])]),t._v(" "),e("ul",[e("li",[t._v("private: 客户端可以缓存")]),t._v(" "),e("li",[t._v("public： 客户端和代理服务器都可以缓存")]),t._v(" "),e("li",[t._v("max-age=t：缓存内容将在t秒后失效")]),t._v(" "),e("li",[t._v("no-cache： 需要用协商缓存来验证缓存数据")]),t._v(" "),e("li",[t._v("no-store： 所有内容都不会缓存")])]),t._v(" "),e("h3",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),e("p",[e("strong",[t._v("last-modified")]),t._v(": 服务器请求时会告诉资源的最后修改时间\n"),e("strong",[t._v("if-modified-since")]),t._v("：浏览器请求服务器时，请求头会包含这个参数，后面跟着缓存中获得最后修改时间。服务端收到请求头发现该字段ifmodifiedsince，则与被请求资源的最后修改时间进行比对，如果一致则返回304和响应报文头，浏览器直接从缓存中获取信息。")]),t._v(" "),e("ul",[e("li",[t._v("如果被修改：返回200，以及新资源")]),t._v(" "),e("li",[t._v("如果没有修改： 那么只响应header，返回304\n"),e("strong",[t._v("if-Unmodified-Since")]),t._v(": 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。")]),t._v(" "),e("li",[t._v("如果被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)")]),t._v(" "),e("li",[t._v("如果没有修改： 则开始`继续'传送文件，服务器返回: 200 OK\n"),e("strong",[t._v("Etag")]),t._v("： 服务器响应请求时，会告诉浏览器当前资源在服务器生成的唯一标识(服务器决定生成规则)\n"),e("strong",[t._v("if-match")]),t._v(":条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改\n"),e("strong",[t._v("if-None-match")]),t._v(":再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。")]),t._v(" "),e("li",[t._v("不同，说明资源被改动过，则响应整个资源内容，返回状态码200。")]),t._v(" "),e("li",[t._v("相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.")])]),t._v(" "),e("h2",{attrs:{id:"首屏加载优化方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首屏加载优化方案","aria-hidden":"true"}},[t._v("#")]),t._v(" 首屏加载优化方案")]),t._v(" "),e("ul",[e("li",[t._v("vue ssr服务端渲染")]),t._v(" "),e("li",[t._v("vue-router路由懒加载（webpack做代码切割）")])]),t._v(" "),e("blockquote",[e("p",[t._v("将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)，然后在import动态引入")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Foo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" Promise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 组件定义对象 */")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Foo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./Foo.vue'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("ul",[e("li",[t._v("使用CDN加速，将通用的库从vendor进行抽离，上传到CDN")]),t._v(" "),e("li",[t._v("使用gZip压缩")]),t._v(" "),e("li",[t._v("使用异步组件")]),t._v(" "),e("li",[t._v("UI库的按需加载")]),t._v(" "),e("li",[t._v("Service Worker缓存文件处理")]),t._v(" "),e("li",[t._v("使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度")])]),t._v(" "),e("h2",{attrs:{id:"http相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http相关","aria-hidden":"true"}},[t._v("#")]),t._v(" http相关")]),t._v(" "),e("h3",{attrs:{id:"http2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2","aria-hidden":"true"}},[t._v("#")]),t._v(" http2")]),t._v(" "),e("h4",{attrs:{id:"二进制分帧："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("二进制分帧")]),t._v("：")]),t._v(" "),e("p",[t._v("帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。")]),t._v(" "),e("p",[t._v("流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID")]),t._v(" "),e("p",[t._v("HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。")]),t._v(" "),e("h4",{attrs:{id:"头部压缩："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("头部压缩")]),t._v("：")]),t._v(" "),e("p",[t._v("HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。")]),t._v(" "),e("ul",[e("li",[t._v("HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送")]),t._v(" "),e("li",[t._v("首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;")]),t._v(" "),e("li",[t._v("每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。")])]),t._v(" "),e("h4",{attrs:{id:"服务器推送："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("服务器推送")]),t._v("：")]),t._v(" "),e("p",[t._v("服务端可以"),e("strong",[t._v("在发送页面HTML时主动推送其它资源")]),t._v("，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。")]),t._v(" "),e("p",[t._v("服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，"),e("strong",[t._v("浏览器可以通过发送RST_STREAM帧来拒收")]),t._v("。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。")]),t._v(" "),e("h4",{attrs:{id:"多路复用："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("多路复用")]),t._v("：")]),t._v(" "),e("p",[t._v("HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。")]),t._v(" "),e("p",[t._v("HTTP2中：")]),t._v(" "),e("ul",[e("li",[t._v("同域名下所有通信都在单个连接上完成。")]),t._v(" "),e("li",[t._v("单个连接可以承载任意数量的双向数据流。")]),t._v(" "),e("li",[t._v("数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装")])]),t._v(" "),e("h3",{attrs:{id:"tcp-三次握手和四次握手的区别，为什么存在"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手和四次握手的区别，为什么存在","aria-hidden":"true"}},[t._v("#")]),t._v(" tcp 三次握手和四次握手的区别，为什么存在")]),t._v(" "),e("h4",{attrs:{id:"三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),e("p",[t._v("所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。\n三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。")]),t._v(" "),e("ul",[e("li",[t._v("第一次握手(SYN=1, seq=x):\n客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n发送完毕后，客户端进入 SYN_SEND 状态。")]),t._v(" "),e("li",[t._v("第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):\n服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。")]),t._v(" "),e("li",[t._v("第三次握手(ACK=1，ACKnum=y+1)\n客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1\n发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。")])]),t._v(" "),e("h4",{attrs:{id:"四次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四次握手","aria-hidden":"true"}},[t._v("#")]),t._v(" 四次握手")]),t._v(" "),e("p",[t._v("TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。")]),t._v(" "),e("ul",[e("li",[t._v("第一次挥手(FIN=1，seq=x)\n假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。\n发送完毕后，客户端进入 FIN_WAIT_1 状态。")]),t._v(" "),e("li",[t._v("第二次挥手(ACK=1，ACKnum=x+1)\n服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。\n发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。")]),t._v(" "),e("li",[t._v("第三次挥手(FIN=1，seq=y)\n服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。\n发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。")]),t._v(" "),e("li",[t._v("第四次挥手(ACK=1，ACKnum=y+1)\n客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。\n服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。\n客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);