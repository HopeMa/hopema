(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{221:function(e,t,r){"use strict";r.r(t);var n=r(0),i=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"前端性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端性能优化")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/5a966bd16fb9a0635172a50a",target:"_blank",rel:"noopener noreferrer"}},[e._v("2018 前端性能优化清单"),r("OutboundLink")],1)]),e._v(" "),r("h3",{attrs:{id:"前端性能优化方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化方案","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端性能优化方案")]),e._v(" "),r("p",[e._v("前端性能优化tree-shaking（无用代码移除）、scope hoisting（作用域提升）、code-splitting（按需加载）、 intersection observer 以及 clients hints、CSS containment、HTTP/2 和 service workers 这些技术都是有利于性能优化的")]),e._v(" "),r("ol",[r("li",[e._v("tree-shaking：tree-shaking 是 Webpack 2 引入的新功能，tree-shaking 是无用代码移除（DCE, dead code elimination）的一个方法，但和传统的方法不太一样。tree-shaking 找到需要的代码，灌入最终的结果；传统 DCE 找到执行不到的代码，从 AST 里清除。—— "),r("a",{attrs:{href:"https://www.zhihu.com/question/41922432",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何评价 Webpack 2 新引入的 Tree-shaking 代码优化技术？"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("scope hoisting：scope hoisting 是 Webpack 3 的新功能，又译作“作用域提升”。Webpack 将所有模块都用函数包裹起来，然后自己实现了一套模块加载、执行与缓存的功能，使用这样的结构是为了更容易实现 Code Splitting（包括按需加载）、模块热替换等功能。—— "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27980441",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack 3 的新功能：Scope Hoisting"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("code-splitting：对于大型的 web 应用而言，把所有的代码放到一个文件的做法效率很差，特别是在加载了一些只有在特定环境下才会使用到的阻塞的代码的时候。Webpack有个功能会把你的代码分离成Chunk，后者可以按需加载。这个功能就是code-splitting。—— "),r("a",{attrs:{href:"http://www.alloyteam.com/2016/02/code-split-by-routes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("在Webpack中使用Code Splitting实现按需加载"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v('intersection observer：可以自动"观察"元素是否可见，由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做"交叉观察器"。—— '),r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("IntersectionObserver API 使用教程"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("clients hints：自动响应式图片 —— "),r("a",{attrs:{href:"https://cloudinary.com/blog/automatic_responsive_images_with_client_hints",target:"_blank",rel:"noopener noreferrer"}},[e._v("Automatic responsive images with Client Hints"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("CSS containment：新的 CSS 属性 Containment 允许开发者限制浏览器样式、布局和 paint 工作的范围。—— "),r("a",{attrs:{href:"https://developers.google.com/web/updates/2016/06/css-containment",target:"_blank",rel:"noopener noreferrer"}},[e._v("CSS Containment in Chrome 52"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("service workers：实现离线页面 —— "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",target:"_blank",rel:"noopener noreferrer"}},[e._v("Service worker concepts and usage"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"前端性能度量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端性能度量","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端性能度量")]),e._v(" "),r("ol",[r("li",[e._v("首次有效渲染（FMP，是指主要内容出现在页面上所需的时间），")]),e._v(" "),r("li",[e._v("重要渲染时间（页面最重要部分渲染完成所需的时间），")]),e._v(" "),r("li",[e._v("可交互时间（TTI，是指页面布局已经稳定，关键的页面字体已经可见，主进程可以足够的处理用户的输入 —— 基本的时间标记是，用户可以在 UI 上进行点击和交互），")]),e._v(" "),r("li",[e._v("输入响应，接口响应用户操作所需的时间，")]),e._v(" "),r("li",[e._v("Speed Index，测量填充页面内容的速度。 分数越低越好，")]),e._v(" "),r("li",[e._v("自定义度量，由你的业务需求和用户体验来决定。")])])])}),[],!1,null,null,null);t.default=i.exports}}]);