<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue使用总结 | HopeMa学习历程</title>
    <meta name="description" content="技术学习进阶之路">
    
    
    <link rel="preload" href="/hopema/assets/css/0.styles.aff9224e.css" as="style"><link rel="preload" href="/hopema/assets/js/app.e2d1272e.js" as="script"><link rel="preload" href="/hopema/assets/js/2.ba40ddf8.js" as="script"><link rel="preload" href="/hopema/assets/js/17.14e0ba0d.js" as="script"><link rel="prefetch" href="/hopema/assets/js/10.201fb3bc.js"><link rel="prefetch" href="/hopema/assets/js/11.15daefdd.js"><link rel="prefetch" href="/hopema/assets/js/12.816b6775.js"><link rel="prefetch" href="/hopema/assets/js/13.8b5c7696.js"><link rel="prefetch" href="/hopema/assets/js/14.904ffc34.js"><link rel="prefetch" href="/hopema/assets/js/15.aef4f661.js"><link rel="prefetch" href="/hopema/assets/js/16.3c672fff.js"><link rel="prefetch" href="/hopema/assets/js/18.5ac82b3f.js"><link rel="prefetch" href="/hopema/assets/js/19.540b52fc.js"><link rel="prefetch" href="/hopema/assets/js/20.72ee5932.js"><link rel="prefetch" href="/hopema/assets/js/21.e7d4ff7c.js"><link rel="prefetch" href="/hopema/assets/js/22.8588407c.js"><link rel="prefetch" href="/hopema/assets/js/23.89752d53.js"><link rel="prefetch" href="/hopema/assets/js/24.f2cbff77.js"><link rel="prefetch" href="/hopema/assets/js/25.b323639f.js"><link rel="prefetch" href="/hopema/assets/js/26.0bfbb238.js"><link rel="prefetch" href="/hopema/assets/js/27.182b773a.js"><link rel="prefetch" href="/hopema/assets/js/28.5926a989.js"><link rel="prefetch" href="/hopema/assets/js/29.0e1591f4.js"><link rel="prefetch" href="/hopema/assets/js/3.044ad3b5.js"><link rel="prefetch" href="/hopema/assets/js/4.a41b7f7d.js"><link rel="prefetch" href="/hopema/assets/js/5.da5be34a.js"><link rel="prefetch" href="/hopema/assets/js/6.7762016d.js"><link rel="prefetch" href="/hopema/assets/js/7.281fe1c0.js"><link rel="prefetch" href="/hopema/assets/js/8.793db6d7.js"><link rel="prefetch" href="/hopema/assets/js/9.d1850baa.js">
    <link rel="stylesheet" href="/hopema/assets/css/0.styles.aff9224e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/hopema/" class="home-link router-link-active"><!----> <span class="site-name">HopeMa学习历程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/hopema/" class="nav-link">主页</a></div><div class="nav-item"><a href="/hopema/vue3/" class="nav-link">vue3源码导读</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">技术·杂谈</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/article/" class="nav-link">技术优质文章集</a></li><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/forntBack/" class="nav-link">前端可视化后台</a></li><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/wechatRobot/" class="nav-link">微信机器人搭建</a></li><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/video_audio/article.html" class="nav-link">音视频相关</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端·面试</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/interview/zero.html" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/js_libraries/one.html" class="nav-link">js库学习</a></li><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/electron/one.html" class="nav-link">electron学习</a></li><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/worklearn/one.html" class="nav-link">工作积累学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机·基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hopema/basiccomputer/algorithm/one.html" class="nav-link">算法基础合集</a></li><li class="dropdown-item"><!----> <a href="/hopema/basiccomputer/webrtc/webrtc.html" class="nav-link">webRTC</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/HopeMa/hopema" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/hopema/" class="nav-link">主页</a></div><div class="nav-item"><a href="/hopema/vue3/" class="nav-link">vue3源码导读</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">技术·杂谈</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/article/" class="nav-link">技术优质文章集</a></li><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/forntBack/" class="nav-link">前端可视化后台</a></li><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/wechatRobot/" class="nav-link">微信机器人搭建</a></li><li class="dropdown-item"><!----> <a href="/hopema/technicalTalks/video_audio/article.html" class="nav-link">音视频相关</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端·面试</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/interview/zero.html" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/js_libraries/one.html" class="nav-link">js库学习</a></li><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/electron/one.html" class="nav-link">electron学习</a></li><li class="dropdown-item"><!----> <a href="/hopema/frontInterview/worklearn/one.html" class="nav-link">工作积累学习</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机·基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hopema/basiccomputer/algorithm/one.html" class="nav-link">算法基础合集</a></li><li class="dropdown-item"><!----> <a href="/hopema/basiccomputer/webrtc/webrtc.html" class="nav-link">webRTC</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/HopeMa/hopema" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/hopema/frontInterview/interview/zero.html" class="sidebar-link">ES6知识汇总</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/zero.html#es6总结文章" class="sidebar-link">ES6总结文章</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/zero.html#强缓存和协商缓存" class="sidebar-link">强缓存和协商缓存</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/zero.html#首屏加载优化方案" class="sidebar-link">首屏加载优化方案</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/zero.html#http相关" class="sidebar-link">http相关</a></li></ul></li><li><a href="/hopema/frontInterview/interview/one.html" class="sidebar-link">前端面试手写题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#防抖和节流" class="sidebar-link">防抖和节流</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#深拷贝" class="sidebar-link">深拷贝</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#数组去重、数组乱序" class="sidebar-link">数组去重、数组乱序</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#手写call、apply、bind" class="sidebar-link">手写call、apply、bind</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#继承（es5-es6）" class="sidebar-link">继承（ES5/ES6）</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#sleep函数" class="sidebar-link">sleep函数</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#实现promise" class="sidebar-link">实现promise</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#实现promise-all" class="sidebar-link">实现promise.all</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#实现promise-retry" class="sidebar-link">实现promise.retry</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#将一个同步callback包装成promise形式" class="sidebar-link">将一个同步callback包装成promise形式</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#写一个函数，可以控制最大并发数" class="sidebar-link">写一个函数，可以控制最大并发数</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#jsonp的实现" class="sidebar-link">jsonp的实现</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#eventemitter-emit-on-off-once" class="sidebar-link">eventEmitter(emit,on,off,once)</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#实现instanceof" class="sidebar-link">实现instanceof</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#实现new" class="sidebar-link">实现new</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#实现数组flat、filter等方法" class="sidebar-link">实现数组flat、filter等方法</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/one.html#lazyman" class="sidebar-link">lazyMan</a></li></ul></li><li><a href="/hopema/frontInterview/interview/two.html" class="active sidebar-link">vue问题总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/two.html#vue使用总结" class="sidebar-link">vue使用总结</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/two.html#重绘重排" class="sidebar-link">重绘重排</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/two.html#vue中的provide-inject" class="sidebar-link">vue中的provide/inject</a></li></ul></li><li><a href="/hopema/frontInterview/interview/three.html" class="sidebar-link">前端性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/three.html#前端性能优化" class="sidebar-link">前端性能优化</a></li></ul></li><li><a href="/hopema/frontInterview/interview/four.html" class="sidebar-link">知识总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/four.html#chrome进程" class="sidebar-link">chrome进程</a></li><li class="sidebar-sub-header"><a href="/hopema/frontInterview/interview/four.html#js协程概念" class="sidebar-link">js协程概念</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue使用总结"><a href="#vue使用总结" aria-hidden="true" class="header-anchor">#</a> vue使用总结</h2> <p><a href="https://github.com/fengshi123/blog" target="_blank" rel="noopener noreferrer">vue相关项目总结<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <p>优点：</p> <p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，SPA 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
缺点：</p> <p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
2、v-show 与 v-if 有什么区别？
v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p> <p>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p> <p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p> <p>3、Class 与 Style 如何动态绑定？
Class 可以通过对象语法和数组语法进行动态绑定：</p> <p>对象语法：
</p><div></div><p></p> <p>data: {
isActive: true,
hasError: false
}
数组语法：
</p><div></div><p></p> <p>data: {
activeClass: 'active',
errorClass: 'text-danger'
}
Style 也可以通过对象语法和数组语法进行动态绑定：</p> <p>对象语法：
</p><div style="font-size:undefinedpx;"></div><p></p> <p>data: {
activeColor: 'red',
fontSize: 30
}
数组语法：
</p><div></div><p></p> <p>data: {
styleColor: {
color: 'red'
},
styleSize:{
fontSize:'23px'
}
}
4、怎样理解 Vue 的单向数据流？
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定 ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> <p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <p>有两种常见的试图改变一个 prop 的情形 :</p> <p>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：
props: ['initialCounter'],
data: function () {
return {
counter: this.initialCounter
}
}
这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性
props: ['size'],
computed: {
normalizedSize: function () {
return this.size.trim().toLowerCase()
}
}
5、computed 和 watch 的区别和运用的场景？
computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p> <p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p> <p>运用场景：</p> <p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p> <p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p> <p>6、直接给一个数组项赋值，Vue 能检测到变化吗？
由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p> <p>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
当你修改数组的长度时，例如：vm.items.length = newLength
为了解决第一个问题，Vue 提供了以下操作方法：</p> <p>// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
为了解决第二个问题，Vue 提供了以下操作方法：</p> <p>// Array.prototype.splice
vm.items.splice(newLength)
7、谈谈你对 Vue 生命周期的理解？
（1）生命周期是什么？</p> <p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> <p>（2）各个生命周期的作用</p> <p>生命周期	描述
beforeCreate	组件实例被创建之初，组件的属性生效之前
created	组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用
beforeMount	在挂载开始之前被调用：相关的 render 函数首次被调用
mounted	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子
beforeUpdate	组件数据更新之前调用，发生在虚拟 DOM 打补丁之前
update	组件数据更新之后
activited	keep-alive 专属，组件被激活时调用
deadctivated	keep-alive 专属，组件被销毁时调用
beforeDestory	组件销毁前调用
destoryed	组件销毁后调用
（3）生命周期示意图</p> <p>1.png</p> <p>8、Vue 的父组件和子组件生命周期钩子函数执行顺序？
Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p> <p>加载渲染过程</p> <p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p> <p>子组件更新过程</p> <p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p> <p>父组件更新过程</p> <p>父 beforeUpdate -&gt; 父 updated</p> <p>销毁过程</p> <p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p> <p>9、在哪个生命周期内调用异步请求？
可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <p>能更快获取到服务端数据，减少页面 loading 时间；
ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
10、在什么阶段才能访问操作DOM？
在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p> <p>1.png</p> <p>11、父组件可以监听到子组件的生命周期吗？
比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p> <p>// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;</p> <p>// Child.vue
mounted() {
this.$emit(&quot;mounted&quot;);
}
以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p> <p>//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;</p> <p>doSomething() {
console.log('父组件监听到 mounted 钩子函数 ...');
},</p> <p>//  Child.vue
mounted(){
console.log('子组件触发 mounted 钩子函数 ...');
},</p> <p>// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...<br>
当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p> <p>12、谈谈你对 keep-alive 的了解？
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p> <p>一般结合路由和动态组件一起使用，用于缓存组件；
提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。
13、组件中 data 为什么是一个函数？
为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// data</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
	message<span class="token punctuation">:</span> <span class="token string">&quot;子组件&quot;</span><span class="token punctuation">,</span>
	childName<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// new Vue</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  router<span class="token punctuation">,</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;App/&gt;'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>App<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p> <p>14、v-model 的原理？
我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <p>text 和 textarea 元素使用 value 属性和 input 事件；
checkbox 和 radio 使用 checked 属性和 change 事件；
select 字段将 value 作为 prop 并将 change 作为事件。
以 input 表单元素为例：</p> <input> <p>相当于</p> <input>
如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：
<p>父组件：
<ModelChild></ModelChild></p> <p>子组件：
</p><div></div><p></p> <p>props:{
value: String
},
methods: {
test1(){
this.$emit('input', '小红')
},
},
15、Vue 组件间通信有哪几种方式？
Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p> <p>（1）props / $emit 适用 父子组件通信</p> <p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p> <p>（2）ref 与 $parent / $children 适用 父子组件通信</p> <p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
$parent / $children：访问父 / 子实例
（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</p> <p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p> <p>（4）$attrs/$listeners 适用于 隔代组件通信</p> <p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。
$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件
（5）provide / inject 适用于 隔代组件通信</p> <p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p> <p>（6）Vuex 适用于 父子、隔代、兄弟组件通信</p> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p> <p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。
16、你使用过 Vuex 吗？
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p> <p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p> <p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p> <p>主要包括以下几个模块：</p> <p>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。
17、使用过 Vue SSR 吗？说说 SSR？
Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p> <p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p> <p>服务端渲染 SSR 的优缺点如下：</p> <p>（1）服务端渲染的优点：</p> <p>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；
更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；
（2) 服务端渲染的缺点：</p> <p>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；
更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。
如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。</p> <p>18、vue-router 路由模式有几种？
vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">'history'</span><span class="token punctuation">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'hash'</span><span class="token punctuation">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'abstract'</span><span class="token punctuation">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中，3 种路由模式的说明如下：</p> <p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p> <p>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p> <p>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p> <p>19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？
（1）hash 模式的实现原理</p> <p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：</p> <p>https://www.word.com#search
hash 路由模式的实现主要是基于下面几个特性：</p> <p>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。
（2）history 模式的实现原理</p> <p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p> <p>window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
history 路由模式的实现主要基于存在下面几个特性：</p> <p>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；
history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
20、什么是 MVVM？
Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p> <p>MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p> <p>1.png</p> <p>（1）View 层</p> <p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p> <p>（2）Model 层</p> <p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p> <p>（3）ViewModel 层</p> <p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p> <p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p> <p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p> <div class="language-js extra-class"><pre class="language-js"><code>（<span class="token number">1</span>）View 层

<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token punctuation">:</span>click<span class="token operator">=</span><span class="token string">&quot;showMessage()&quot;</span><span class="token operator">&gt;</span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
（<span class="token number">2</span>）ViewModel 层

<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图状态   </span>
        message<span class="token punctuation">:</span> <span class="token string">'Hello Vue!'</span><span class="token punctuation">,</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图行为  </span>
        <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token comment">// Ajax 获取 Model 层的数据</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            url<span class="token punctuation">:</span> <span class="token string">'/your/server/data/api'</span><span class="token punctuation">,</span>
            <span class="token function">success</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                vm<span class="token punctuation">.</span>message <span class="token operator">=</span> res<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
（<span class="token number">3</span>） Model 层

<span class="token punctuation">{</span>
    <span class="token string">&quot;url&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;/your/server/data/api&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;res&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token string">&quot;success&quot;</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token string">&quot;name&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;IoveC&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;domain&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;www.cnblogs.com&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>21、Vue 是如何实现数据双向绑定的？
Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p> <p>1.png</p> <p>即：</p> <p>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。
Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。
其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p> <p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p> <p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p> <p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p> <p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p> <p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p> <p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。</p> <p>1.png</p> <p>22、Vue 框架怎么实现对象和数组的监听？
如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">/**
   * Observe a list of Array items.
   */</span>
  <span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter">items<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// observe 功能为监测数据的变化</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * 对属性进行递归遍历
   */</span>
  <span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// observe 功能为监测数据的变化</span>
</code></pre></div><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p> <p>23、Proxy 与 Object.defineProperty 优劣对比
Proxy 的优势如下:</p> <p>Proxy 可以直接监听对象而非属性；
Proxy 可以直接监听数组的变化；
Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；
Object.defineProperty 的优势如下:</p> <p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。
24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？
受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p> <p>我们查看对应的 Vue 源码：vue/src/core/instance/index.js</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token punctuation">:</span> any<span class="token punctuation">,</span> val<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式  </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// key 已经存在，直接修改属性值  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><p>我们阅读以上源码可知，vm.$set 的实现原理是：</p> <p>如果目标是数组，直接使用数组的 splice 方法触发相应式；</p> <p>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p> <p>25、虚拟 DOM 的优缺点？
优点：</p> <p>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。
缺点:</p> <p>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
26、虚拟 DOM 实现原理？
虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
diff 算法 — 比较两棵虚拟 DOM 树的差异；
pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。
如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》</p> <p>27、Vue 中的 key 有什么作用？
key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》</p> <p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p> <p>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p> <p>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre></div><p>28、你有对 Vue 项目进行哪些优化？
如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p> <p>（1）代码层面的优化</p> <p>v-if 和 v-show 区分使用场景
computed 和 watch 区分使用场景
v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
长列表性能优化
事件的销毁
图片资源懒加载
路由懒加载
第三方插件的按需引入
优化无限列表性能
服务端渲染 SSR or 预渲染
（2）Webpack 层面的优化</p> <p>Webpack 对图片进行压缩
减少 ES6 转为 ES5 的冗余代码
提取公共代码
模板预编译
提取组件的 CSS
优化 SourceMap
构建结果输出分析
Vue 项目的编译优化
（3）基础的 Web 技术的优化</p> <p>开启 gzip 压缩</p> <p>浏览器缓存</p> <p>CDN 的使用</p> <p>使用 Chrome Performance 查找性能瓶颈</p> <p>29、对于即将到来的 vue3.0 特性你有什么了解的吗？
Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p> <p>（1）监测机制的改变</p> <p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p> <p>只能监测属性，不能监测对象</p> <p>检测属性的添加和删除；</p> <p>检测数组索引和长度的变更；</p> <p>支持 Map、Set、WeakMap 和 WeakSet。</p> <p>新的 observer 还提供了以下特性：</p> <p>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。
默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。
更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。
不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。
更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。
（2）模板</p> <p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p> <p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p> <p>（3）对象式的组件声明方式</p> <p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p> <p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p> <p>（4）其它方面的更改</p> <p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p> <p>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
基于 treeshaking 优化，提供了更多的内置功能。
30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？
本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 ~~~</p> <h2 id="重绘重排"><a href="#重绘重排" aria-hidden="true" class="header-anchor">#</a> 重绘重排</h2> <p>由重排重绘引发对虚拟DOM以及性能优化的思考</p> <p>重排重绘</p> <ul><li>重排：当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中收到影响的部分失效，并重新构造渲染树，这个过程成为重排。</li> <li>重绘：完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称重绘。</li> <li>重排重绘的危害：它们会导致Web应用程序的UI反应迟钝，所以应当尽可能减少这类过程的发生。
触发重排的情况</li> <li>添加或删除可见的DOM元素</li> <li>元素位置的改变</li> <li>元素尺寸的改变</li> <li>元素内容的改变（例如：一个文本被另一个不同尺寸的图片代替）</li> <li>页面渲染初始化（这个无法避免）</li> <li>浏览器窗口尺寸改变
触发重绘的情况</li> <li>字体颜色</li> <li>背景颜色</li></ul> <p>优化</p> <div class="language-js extra-class"><pre class="language-js"><code>读写分离操作
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">'10px'</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>bottom <span class="token operator">=</span> <span class="token string">'10px'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>

样式集中改变
通过<span class="token keyword">class</span>或cssText
<span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginLeft <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>

<span class="token comment">// class</span>
<span class="token punctuation">.</span>className<span class="token punctuation">{</span>
  margin<span class="token operator">-</span>left<span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
  margin<span class="token operator">-</span>top<span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
el<span class="token punctuation">.</span>className <span class="token operator">+=</span> <span class="token string">' className'</span><span class="token punctuation">;</span>
<span class="token comment">// cssText</span>
<span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+=</span> <span class="token string">'margin-left: '</span> <span class="token operator">+</span> Left <span class="token operator">+</span> <span class="token string">'px; margin-top: '</span> <span class="token operator">+</span> Top <span class="token operator">+</span> <span class="token string">'px;'</span>


缓存布局信息
<span class="token comment">// 触发两次重排</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存布局信息 相当于读写分离</span>
<span class="token keyword">var</span> curLeft <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>
<span class="token keyword">var</span> curTop <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> curLeft <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> curTop <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>


离线改变dom
一旦我们给元素设置display<span class="token punctuation">:</span> none<span class="token punctuation">;</span>时，元素不会存在渲染树中，相当于将其从页面<span class="token string">&quot;拿掉&quot;</span>，我们之后的操作将不会触发重排和重绘，这叫做离线化。
dom<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>
<span class="token comment">// 修改dom样式</span>
dom<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>通过使用DomcumentFragment创建一个dom碎片，在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排</p></blockquote> <blockquote><p>复制节点，在副本上工作，如何替换成它。</p></blockquote> <blockquote><p>position属性为absolute或fixed</p></blockquote> <blockquote><p>position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响。</p></blockquote> <p>优化动画</p> <blockquote><p>启动GPU加速。
将2D的transform换成3D就可以强制开启GPU加速，提高动画性能。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>div <span class="token punctuation">{</span>
  transform<span class="token punctuation">:</span> <span class="token function">translate3d</span><span class="token punctuation">(</span><span class="token number">10</span>px<span class="token punctuation">,</span> <span class="token number">10</span>px<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虚拟DOM
什么是虚拟DOM？</p> <p>可以看做是一个使用JavaScript模拟了DOM结构的树形结构，这个树形结构包括整个DOM结构。
VDom特点</p> <p>虚拟DOM不会进行重排和重绘操作。</p> <p>虚拟DOM进行频繁操作，然后一次性修改真实DOM需要改的部分，最后并在真实的DOM中进行排版与重绘，减少过多DOM节点排版和重绘消耗。</p> <p>真实DOM频繁排版和重绘的效率是相当低的。</p> <p>虚拟DOM有效的降低大面积（真实DOM节点）的重排和排版，因为最终与真实DOM比较差异，可以只渲染局部。
为什么使用虚拟DOM？</p> <p>之前使用原生JS或者jQuery写页面的时候会发现操作DOM是一件非常麻烦的事情，往往是DOM标签和JS逻辑同时写在JS文件里，数据交互是不是还要写很多的input隐藏域。如果没有好的代码规范的话会显得代码非常冗余混乱，耦合性高并且难以维护。</p> <p>另一个方面在浏览器一遍又一遍的渲染DOM是非常非常消耗性能的，常常会出现页面卡死的情况。所以尽量减少对DOM的操作成为了优化前端性能的必要手段，vdom就是将DOM的对比放在了JS层，通过对比不同之处来选择新渲染DOM节点，从而提高渲染效率。</p> <p>使用虚拟DOM的损耗计算</p> <p>总消耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘</p> <p>使用真实DOM的损耗计算</p> <p>总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘</p> <p>Diff算法（实现虚拟DOM对真实的DOM的更新）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 创建对比函数</span>
  <span class="token keyword">var</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> newChildren <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">childrenVnode<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> newChilrenVnode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 首先拿到对应新的节点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>childrenVnode<span class="token punctuation">.</span>tag <span class="token operator">=</span> newChildrenVnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断节点是否相同</span>
      <span class="token function">updateChildren</span><span class="token punctuation">(</span>childrenVnode<span class="token punctuation">,</span> newChildVnode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果相同就执行递归，深度对比节点</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">replaceNode</span><span class="token punctuation">(</span>childrenVnode<span class="token punctuation">,</span> newChildVnode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果不同则将旧的节点替换成新的节点</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">replaceNode</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 节点替换函数</span>
  <span class="token keyword">var</span> elem <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>
  <span class="token keyword">var</span> newEle <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="性能优化"><a href="#性能优化" aria-hidden="true" class="header-anchor">#</a> 性能优化</h4> <h5 id="减少http请求-最重要最有效"><a href="#减少http请求-最重要最有效" aria-hidden="true" class="header-anchor">#</a> 减少HTTP请求(最重要最有效)</h5> <p>一个完整的请求都需要DNS寻址丶与服务器建立链接丶发送数据丶等待服务器响应丶接受数据这样一个漫长而复杂的过程。由于浏览器进行并发请求的请求数都是有上限的，因此请求数多了以后，浏览器需要进行分批请求，因此会增加用户的等待时间，给用户造成网站速度慢这种现象，即使可能用户看到的第一屏的资源都已经请求完了，但是浏览器的进度条一直在加载。</p> <h5 id="请求优化（减少http请求数的途径只要有以下几个）"><a href="#请求优化（减少http请求数的途径只要有以下几个）" aria-hidden="true" class="header-anchor">#</a> 请求优化（减少HTTP请求数的途径只要有以下几个）</h5> <ol><li>从设计层面实现优化页面<br>
如果你的页面和百度的页面一眼简单，那么也就不需要什么优化操作了，因此保持页面简洁丶减少资源的使用是最直接的。</li> <li>合理设置HTTP缓存<br>
缓存的力量是强大的，恰当的缓存设置可以大大减少HTTP请求。<br>
怎么样才是合理的缓存，原则很简单：能缓存越多越好。<br>
例如：很少变化的图片资源就可以直接通过HTTP Header中的Expires设置一个很长的过期头，变化不频繁而又可能会变的资源可以使用Last-Modified来做请求校验，尽可能的让资源能够在缓存中待的更久。</li> <li>资源合并与压缩<br>
如果可以的话，尽可能的将外部脚本和样式进行合并，尽可能的合并为一个，另外CSS丶JS丶Image都可以使用相应的工具压缩，压缩往往能节省不少空间，或者使用webpack等前端工厂化工具进行代码的压缩和去重。</li> <li>CSSprites 雪碧图<br>
雪碧图又叫做精灵图，我们可以把网站中需要用到的一些icon全部放在一个图片资源中，如何通过改变位置来获取需要的图片，这样合并CSS图片，就可以大幅度减少HTTP请求数。</li> <li>网页内联图片 html inline image<br>
使用data: URL scheme的方式将图片嵌入到页面或CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法，如果是嵌入页面的话换来的是增大了页面的体积，而不法利用好浏览器缓存，使用CSS中的图片的更加理想一些。</li> <li>懒加载(Lazy Load Image)<br>
这条策略实际上并不一定减少HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求。对于图片而言，在页面加载的时候只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片，这样一来，假如用户只对第一屏的内容感兴趣的时，那剩余的图片请求都节省了。有的首页曾经的做法是在加载的时候把第一屏的之后的图片地址缓存在Textarea中，待用户往下滚屏的时候才&quot;惰性&quot;加载。</li> <li>瀑布流<br>
其实懒加载并不能减少HTTP请求数，它只是减少页面刚加载的时候的HTTP请求数，总数是不变的。对于图片而言，在页面加载的时候可能只加载第一屏的图片，随着用户的滚动才会加载后面的图片资源，这种瀑布流的加载方式就可以有效提高性能。</li> <li>减少不必要的HTTP跳转<br>
对于以目录形式访问的HTTP链接，很多人都会忽略最后是否带了&quot;/&quot;加入，服务器对此区别对待的话，那么你也要注意了，这其中可能隐藏了301跳转，增加了多余请求。</li> <li>避免重复的资源请求<br>
这种情况主要是由于在模块化开发的时候，我们不同的模块之间可能会有相同的部分，导致资源的重复请求。</li> <li>渲染优化<br>
将外部脚本放在底部<br>
前文有谈到，浏览器是可以并发请求的。这一特点使得其能够更快的加载资源，然而外部脚本在加载的时却会阻塞其他资源。例如在脚本加载完成之前，它后面的图片丶样式以及其他的脚本却处于阻塞状态，直至脚本加载完成后才会加载。如果将脚本放在靠前的位置，则会影响整个页面的加载速度从而影响用户体验，减少这一问题的方法有很多，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。<br>
将CSS放在Head中<br>
如果将CSS放在其他的地方比如body中，则浏览器有可能未下载和解析到CSS就开始渲染页面了，这就导致由无CSS状态跳转到CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在CSS下载完成才开始渲染页面，如果CSS放在靠下的位置则会导致浏览器将渲染事件推迟。</li> <li>慎用with<br>
with会改变作用域链，有可能导致我们的作用域链变长，导致查询性能下降。</li> <li>避免使用eval和Function<br>
每次eval或Function构造函数作用于字符串表示的源代码的时，脚本引擎都需要将源代码转换成可执行的代码，这是很耗费资源的操作。
通常比简单的函数调研慢100倍以上</li> <li>减少作用域链查找<br>
如果在循环中需要访问非作用域下的变量的时候，请遍历之前用局部变量缓存变量，并在遍历结束之后重写缓存变量。</li> <li>减少数据访问<br>
js中对直接量和局部变量的访问时最快的，对对象属性以及数组的访问需要更大的开销，当出现下面的情况的时候，建议将数据放在局部变量。<br>
对任何对象属性的访问超过一次<br>
对任何数组成员的访问次数超过1次<br>
另外，要尽可能的减少对对象以及数组的深度查找。</li> <li>减少字符串的拼接<br>
字符串拼接尽可能少的使用&quot;+&quot;，这种方式的效率是十分低下的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接的结果赋值给新变量。<br>
建议使用的是先转化为数组，如果通过数组的join方法来连接成字符串，不过由于数组也有一定的开销，因此需要权衡一下，当拼接的字符串比较少的时候，可以考虑用&quot;+&quot;的方式，比较多的时候就需要考虑用数组的json方法。</li> <li>减少DOM操作（DOM操作应该是脚本中最耗费性能的一类操作）
HTMLCollection(HTML收集器 返回的是一个数组的内容信息)<br>
因为是这个集合并不是一个静态的集合，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个，查询从而更新查询结果，所谓的&quot;访问集合&quot;包括读取集合的length属性丶访问集合中的元素。</li> <li>避免重排查绘<br>
页面有三个树：DOMTree丶CSSTree丶renderTree（实际上多余三个），renderTree上有两个规则，重排（reflow）和重绘（repaint）。<br>
重绘是元素自身的位置和宽高不变，只改变颜色之类的属性而不会导致后面的元素位置的变化的位置。<br>
renderTree发生的动作，重排是元素自身的位置或宽高改变了从而导致的整个页面的大范围移动的时候，renderTree发生的动作，所以我们在DOM操作的时候，要尽量避免重排。</li> <li>CSS优化<br>
慎用选择高消耗的样式，因为高消耗属性在绘制前需要浏览器需要大量计算。<br>
box-shadow<br>
border-radius<br>
transform<br>
避免过分重排，因为发生重排的时候，浏览器需要重新计算布局的位置与大小<br>
常见的重排元素<br>
width<br>
height<br>
padding<br>
margin<br>
display<br>
border-width<br>
position<br>
float<br>
...<br>
正确使用display属性，因为display属性会影响页面渲染。<br>
display: inline;后不应该使用width/height/margin/padding/float<br>
display: inline-bloack;后不应该使用float<br>
display: block;后不应该使用display: vertical-align;<br>
不滥用float，因为float是渲染时计算量比较大，尽量减少使用。</li> <li>动画性能优化<br>
动画实现的原理是利用了人眼的&quot;视觉暂停&quot;现象，在短时间内连续播放 数幅静止的画面，使肉眼因视觉残象产生错觉，而误以为画面在动。<br>
动画的基本概念<br>
帧：在动画过程中，每一幅静止的画面即为一&quot;帧&quot;<br>
帧频：即每秒中播放的静止画面的停留时间，单位为fps（frame per second）<br>
帧时长：即每一幅静止画面停留时间，单位一般是ms（毫秒）<br>
跳帧（掉帧/丢帧）：在帧频固定的动画中，某一帧的时长远高于平均帧时长，导致其后续数帧被挤压丢失的现象。<br>
一般浏览器的渲染的渲染帧频是60fps，所以在网页当中，帧频如果达到50-60fps将会相当流畅，让人感到舒畅。<br>
如果使用基于JavaScript的动画，尽量使用requestAnimationFrame避免使用setTimout/setInterval<br>
避免通过类似jQuery animation style改变帧频的样式，使用CSS声明，动画会得到更好的浏览器优化。<br>
使用translate取代absolute定位就会得到更好的fps，动画会更加流畅。<br>
多使用硬件能力，如通过3D变形加速开启GPU加速。</li> <li>提高CSS选择器性能<br>
因为CSS选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多的匹配时间的选择器，CSS选择器是从右往左进行规则匹配的。<br>
减少搜索个数<br>
多使用类选择器少使用标签选择器
减少层数<br>
使用BEM的命方式
使用面向对象的命名方式</li></ol> <h2 id="vue中的provide-inject"><a href="#vue中的provide-inject" aria-hidden="true" class="header-anchor">#</a> vue中的provide/inject</h2> <p>provide/inject 是 Vue 在 2.2.0 版本新增的 API，官网介绍如下</p> <blockquote><p><span bgcolor="yellow">这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</span>
应用场景：</p></blockquote> <ol><li>小项目的全局变量</li> <li>组件库的组件开发（在不知道内部传递几层时，这个是一个很好的解决方案）</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父级组件提供 'foo'</span>
<span class="token keyword">var</span> Provider <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    foo<span class="token punctuation">:</span> <span class="token string">'bar'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子组件注入 'foo'</span>
<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>
  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// =&gt; &quot;bar&quot;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/hopema/frontInterview/interview/one.html" class="prev">前端面试手写题</a></span> <span class="next"><a href="/hopema/frontInterview/interview/three.html">前端性能优化</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/hopema/assets/js/app.e2d1272e.js" defer></script><script src="/hopema/assets/js/2.ba40ddf8.js" defer></script><script src="/hopema/assets/js/17.14e0ba0d.js" defer></script>
  </body>
</html>
