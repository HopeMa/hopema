---
# sidebar: auto
---
## ES6总结文章
[《ECMAScript 6 入门》(阮一峰)](http://es6.ruanyifeng.com/)

[前端面试与进阶指南](https://www.cxymsg.com/guide/vue.html)

[FE-Interview](http://blog.poetries.top/FE-Interview-Questions/)

[1.5万字概括ES6全部特性(看图就能记下，值得收藏)](https://juejin.im/post/5d9bf530518825427b27639d)

## 强缓存和协商缓存
### 强缓存

**Cache-Control：**
* private: 客户端可以缓存
* public： 客户端和代理服务器都可以缓存
* max-age=t：缓存内容将在t秒后失效
* no-cache： 需要用协商缓存来验证缓存数据
* no-store： 所有内容都不会缓存

### 协商缓存
**last-modified**: 服务器请求时会告诉资源的最后修改时间
**if-modified-since**：浏览器请求服务器时，请求头会包含这个参数，后面跟着缓存中获得最后修改时间。服务端收到请求头发现该字段ifmodifiedsince，则与被请求资源的最后修改时间进行比对，如果一致则返回304和响应报文头，浏览器直接从缓存中获取信息。
* 如果被修改：返回200，以及新资源
* 如果没有修改： 那么只响应header，返回304
**if-Unmodified-Since**: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。
* 如果被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)
* 如果没有修改： 则开始`继续'传送文件，服务器返回: 200 OK
**Etag**： 服务器响应请求时，会告诉浏览器当前资源在服务器生成的唯一标识(服务器决定生成规则)
**if-match**:条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改
**if-None-match**:再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。
* 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
* 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.

## 首屏加载优化方案
* vue ssr服务端渲染
* vue-router路由懒加载（webpack做代码切割）
> 将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)，然后在import动态引入
~~~ js 
const Foo = () => Promise.resolve({ /* 组件定义对象 */ })
const Foo = () => import('./Foo.vue')
~~~
* 使用CDN加速，将通用的库从vendor进行抽离，上传到CDN
* 使用gZip压缩
* 使用异步组件
* UI库的按需加载
* Service Worker缓存文件处理
* 使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度

## http相关
### http2
#### **二进制分帧**：
帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。

流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID

HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。
#### **头部压缩**：
HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。

* HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送
* 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
* 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。
#### **服务器推送**：
服务端可以**在发送页面HTML时主动推送其它资源**，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，**浏览器可以通过发送RST_STREAM帧来拒收**。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

#### **多路复用**：
HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。

HTTP2中：

* 同域名下所有通信都在单个连接上完成。
* 单个连接可以承载任意数量的双向数据流。
* 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

### tcp 三次握手和四次握手的区别，为什么存在
#### 三次握手
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。
三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。
* 第一次握手(SYN=1, seq=x):
客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
发送完毕后，客户端进入 SYN_SEND 状态。
* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):
服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。
* 第三次握手(ACK=1，ACKnum=y+1)
客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

#### 四次握手
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。
* 第一次挥手(FIN=1，seq=x)
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
发送完毕后，客户端进入 FIN_WAIT_1 状态。
* 第二次挥手(ACK=1，ACKnum=x+1)
服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
* 第三次挥手(FIN=1，seq=y)
服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。
*  第四次挥手(ACK=1，ACKnum=y+1)
客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。
服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。